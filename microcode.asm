; Titan Microcode
; Copyright (C) 2012 Marc Cleave, bootnecklad@gmail.com
; Assume that all bits are L unless specified here
; [H] - Set bit high until turned L
; [L] - Set bit L
; [S] - Set bit on only for that microinstruction
; 
; Key:
; H - High
; L - Low
; R - Read
; W - Write
;
; eg IR1_L_R
;
; Instruction register 1 low nybble to read register
;
; Microcode in the PROMs is arranged as 256words by 56bits so in hex(filled with all 1's) would look like the following:

; ADDR    CONTENTS
; 00:FFFFFFFFFFFFFF
; 01:FFFFFFFFFFFFFF
; 02:FFFFFFFFFFFFFF
; ...
; FD:FFFFFFFFFFFFFF
; FE:FFFFFFFFFFFFFF
; FF:FFFFFFFFFFFFFF
;
; An important aspect of the microcode is the PROM that contains the next 
; address for the microinstructions, this is generated by the microassembler ..
;
; Every time the clock is incremented a new address is fetched from the
;'next microaddress PROM'.
;
; So effectively, evey clock pulse you execute a microcode instruction.
; This is because once a new address is fetched, then you have the
; output of the microcode PROMs. Its reasonably efficient.
;
; The first few microinstructions check for interrupts and deal with
; if needed, if not then they fetch a byte from the main memory and
; write it to the instruction register. The value in the instruction
; register is then used as a direct index to get the next address from
; the 'next microaddress prom'.
;
; Instruction execution continues from there, and when the instruction
; has finished executing then the sequencers last next microaddress will be 
; 00 and the whole process starts again




Instruction Fetch:
   0) MEM_OE[H], MEM_R[H], MEM_EN[H]
   1) W_IR0[S]

ADD,ADC,SUB,AND,LOR,XOR,NOT,SHR:
   0) INC_PC[S]  ; Increments program counter
   1) MEM_OE[H], MEM_R[H], MEM_EN[H]   ; Enables operand to be read from memory
   2) W_IR1[S]   ; Writes operand to operand register
   3) IR1_H_R_REG[H], R_REG[H], MEM_OE[L], MEM_R[L], MEM_EN[L]   ; Routes H byte of operand to read register
   4) W_ALU_A[S]   ; Writes A input of ALU
   5) IR1_L_R[H], IR1_H_R_REG[L], R_REG[L]   ; Routes L byte of operand to read register
   6) W_ALU_B[S]   ; Writes B input of ALU
   7) ALU_DECODER[H], IR1_L_W_REG[H]   ; Selects ALU operation, routes low byte of IR0 to decoder for ALU
   8) W_REG[S]   ; Writes destination register

PUSH:
   0) IR0_L_R[H], R_REG[H], DB_STK_EN[H], STK_CLK[S]
   1) STK_WE[S]
   2) R_REG[L], INC_PC[S]

POP:
   0) IR0_L_R[H], R_REG[H], STK_DB_EN[H]
   1) W_REG[S]
   2) R_REG[L], INC_PC[S], DEC_STK[H]
   3) STK_CLK[S]
   4) DEC_STK[L]
   5) STK_CLK[S]
   6) DEC_STK[H]

MOV:
   0) INC_PC[S]
   1) MEM_OE[H], MEM_R[H], MEM_EN[H]
   2) W_IR1[S]
   3) IR1_H_R_REG[H], R_REG[H], IR1_L_W_REG[H], MEM_OE[L], MEM_R[L], MEM_EN[L]
   4) W_REG[S], INC_PC[S]

JMP:
   0) INC_PC[S]
   1) MEM_OE[H], MEM_R[H], MEM_EN[H]
   2) W_IR1[S]
   3) INC_PC[S], MEM_OE[L], MEM_R[L], MEM_EN[L]
   4) MEM_OE[H], MEM_R[H], MEM_EN[H]
   5) W_IR2[S]
   6) PC_L_W_REG[H], OUT_IR2[H]
   7) W_REG[S]
   8) PC_H_W_REG[H], OUT_IR2[L], OUT_IR1[H]
   9) W_REG[S]

JPZ,JPS,JPC:
   0) INC_PC[S]
   1) MEM_OE[H], MEM_R[H], MEM_EN[H]
   2) W_IR1[S]
   3) INC_PC[S], MEM_OE[L], MEM_R[L], MEM_EN[L]
   4) MEM_OE[H], MEM_R[H], MEM_EN[H]
   5) W_IR2[S]
   6) INC_PC[S]
   7) MC_RESET_EN[S]   ; If the flag is set of the instruction then the microcode counter is reset, instruction doesnt execute
   8) PC_L_W_REG[H], OUT_IR2[H]
   9) W_REG[S]
   A) PC_H_W_REG[H], OUT_IR2[L], OUT_IR1[H]
   B) W_REG[S]

JPI:
   0) INC_PC[S]
   1) MEM_OE[H], MEM_R[H], MEM_EN[H]
   2) W_IR1[S]
   3) INC_PC[S], MEM_OE[L], MEM_R[L], MEM_EN[L]
   4) MEM_OE[H], MEM_R[H], MEM_EN[H]
   5) W_IR2[S]
   6) IR_MEM_READ[H]
   7) MEM_OE[H], MEM_R[H], MEM_EN[H]
   8) W_IR1[S]
   9) INC_PC[S], MEM_OE[L], MEM_R[L], MEM_EN[L]
   A) MEM_OE[H], MEM_R[H], MEM_EN[H]
   B) W_IR2[S]
   C) PC_L_W_REG[H], OUT_IR2[H]
   D) W_REG[S]
   E) PC_H_W_REG[H], OUT_IR2[L], OUT_IR1[H]
   F) W_REG[S]

JSR:
   0) PC_L_W_REG[H], R_REG[H], DB_STK_EN[H], STK_CLK[S]
   1) STK_WE[S]
   2) R_REG[L], STK_DB_EN[L]
   3) PC_L_W_REG[H], R_REG[H], DB_STK_EN[H], STK_CLK[S]
   4) STK_WE[S]
   5) R_REG[L], STK_DB_EN[L]
   6) INC_PC[S]
   7) MEM_OE[H], MEM_R[H], MEM_EN[H]
   8) W_IR1[S]
   9) INC_PC[S], MEM_OE[L], MEM_R[L], MEM_EN[L]
   A) MEM_OE[H], MEM_R[H], MEM_EN[H]
   B) W_IR2[S]
   C) PC_L_W_REG[H], OUT_IR2[H]
   D) W_REG[S]
   E) PC_H_W_REG[H], OUT_IR2[L], OUT_IR1[H]
   F) W_REG[S]

RTN:
   0) PC_H_W_REG[H], R_REG[H], STK_DB_EN[H]
   1) W_REG[S]
   2) R_REG[L], INC_PC[S], Decrement STACK_POINTER
   3) PC_H_W_REG[H], STK_DB_EN[H]
   4) W_REG[S]
   5) R_REG OFF, INC_PC[S], DEC_STK[H]
   6) STK_CLK[S]
   7) DEC_STK[L]
   8) STK_CLK[S]
   9) DEC_STK[H]

JMI 0xZZZZ:
   0) INC_PC[S]
   1) MEM_OE[H], MEM_R[H], MEM_EN[H], PC_L_W_REG[H]
   2) W_REG[S]
   3) INC_PC[S], PC_L_W_REG[H], MEM_OE[L], MEM_R[L], MEM_EN[L]
   4) MEM_OE[H], MEM_R[H], MEM_EN[H]
   5) W_ALU_B[S]
   6) 0x01->R_REG
   7) W ALU_A
   8) ADD to ALU_DECODER, 0xFE->W_REG
   9) W W_REG
   A) Enable NOT_MC_C_RESET, CLR ALU_B ; If the flag is set, H byte of PC needs to be increment
   B) 0xFF->R_REG
   C) W ALU_A
   D) ADC to ALU_DECODER, 0xFF->W_REG
   E) W W_REG

JMI [R1,R2]:
   0) 0x01->R_REG, 0xFF->W_REG
   1) W_REG
   2) 0x02->R_REG, 0xFE->W_REG
   3) W_REG

LDI 0xZZZZ:
   0) INC_PC[S]
   1) Output signals for memory read
   2) W IR1
   3) INC_PC[S]
   4) Output signals for memory read
   5) W ALU_B
   6) 0x01->R_REG
   7) W ALU_A, ADD to ALU_DECODER
   8) W IR2, 0xD->MICROCODE_STEP   ; Load previous step, then increment then step E will be loaded into microcode registers
   9) NOT_MC_C to load MICROCODE_STEP, CLR ALU_B ; If the flag is set, H byte of address needs to be increment
   A) Output IR0 to Databus
   B) W ALU_A
   C) ADC to ALU_DECODER
   D) W IR1
   E) Enable IR memory read signal, IR0_L->W_REG
   F) W_REG

STI 0xZZZZ:
   0) INC_PC[S]
   1) Output signals for memory read
   2) W IR1
   3) INC_PC[S]
   4) Output signals for memory read
   5) W ALU_B
   6) 0x01->R_REG
   7) W ALU_A, ADD to ALU_DECODER
   8) W IR2, 0xD->MICROCODE_STEP   ; Load previous step, then increment then step E will be loaded into microcode registers
   9) NOT_MC_C to load MICROCODE_STEP, CLR ALU_B ; If the flag is set, H byte of address needs to be increment
   A) Output IR0 to Databus
   B) W ALU_A
   C) ADC to ALU_DECODER
   D) W IR1
   E) Enable IR memory W signal, IR0_L->R_REG
   F) W memory

LDI [R1,R2]:
   0) 0x01->R_REG
   1) W IR1
   2) 0x02->R_REG
   3) W IR2
   4) Enable IR memory read signal, IR0_L->W_REG
   5) W_REG

STI [R1,R2]:
   0) 0x01->R_REG
   1) W IR1
   2) 0x02->R_REG
   3) W IR2
   4) Enable IR memory W signal, IR0_L->R_REG
   5) W memory

LDC:
   0) INC_PC[S]
   1) Output signals for memory read, IR0_L->W_REG
   2) W_REG

LDM:
   0) INC_PC[S]
   1) Output signals for memory read
   2) W IR1
   3) INC_PC[S]
   4) Output signals for memory read
   5) W IR2
   6) Enable IR memory read signal, IR0_L->W_REG
   7) W_REG

STM:
   0) INC_PC[S]
   1) Output signals for memory read
   2) W IR1
   3) INC_PC[S]
   4) Output signals for memory read
   5) W IR2
   6) Enable IR memory W signal, IR0_L->R_REG
   7) W memory