; Titan Microcode
; Copyright (C) 2012 Marc Cleave, bootnecklad@gmail.com
;
; The actual PROMs used are 65536*16...
;
; The microcode stored in the PROMs is arranged as lots of words by 48bits so in hex
; (filled with all 1's and NEXT address pointing to the next address)
; would look like the following:

; ADDR  PROM0  PROM1  PROMT2  NEXT
; 00:   FFFF   FFFF   FFFF    01
; 01:   FFFF   FFFF   FFFF    02
; 02:   FFFF   FFFF   FFFF    03
; ...
; FD:   FFFF   FFFF   FFFF    FE
; FE:   FFFF   FFFF   FFFF    FF
; FF:   FFFF   FFFF   FFFF    00
;
; An important aspect of the microcode is the PROM that contains the next 
; address for the microinstructions, this is generated by the microassembler ..
;
; Every time the clock is incremented a new address is fetched from the
;'next microaddress PROM'.
;
; So effectively, evey clock pulse you execute a microcode instruction.
; This is because once a new address is fetched, then you have the
; output of the microcode PROMs. Its reasonably efficient.
;
; The first few microinstructions check for interrupts and deal with
; if needed, if not then they fetch a byte from the main memory and
; write it to the instruction register. The value in the instruction
; register is then used as a direct index to get the next address from
; the 'next microaddress prom'.
;
; Instruction execution continues from there, and when the instruction
; has finished executing then the sequencers last next microaddress will be 
; 00 and the whole process starts again

;;; defines tags for wire names for microcode
(define wire-tags '(ALU-OUTPUT               ; Select ALU to output buffer to databus
		    ALU-MODE-CONTROL         ; Select the ALU mode control line
		    ALU-CARRY-IN             ; Carry in of ALU
		    ALU-FUNCTION-SELECT-3    ; 16 ALU functions
		    ALU-FUNCTION-SELECT-2
		    ALU-FUNCTION-SELECT-1
		    ALU-FUNCTION-SELECT-0
		    ALU-FLAGS-CLK            ; Writes flags to flag register, ZERO, SIGN & CARRY
		    STACK-OUTPUT-ENABLE      ; Enables output of stack memory IC
		    STACK-WRITE-ENABLE       ; Enables write of stack memory IC
		    STACK-BUS-ENABLE         ; Enables bus to read/write to stack
		    STACK-BUS-DIRECTION      ; Selects direction to read databus or write stack
		    MEMORY-OUTPUT-ENABLE     ; Enables output of memory IC
		    MEMORY-WRITE-ENABLE      ; Enables write of memory IC
		    MEMORY-BUS-ENABLE        ; Enables bus to read/write to memory
		    MEMORY-BUS-DIRECTION     ; Selects direction to read databus or write memory
		    CONDITIONAL-RESET-ZERO   ; Reset if ZERO flag is set
		    CONDITIONAL-RESET-SIGN   ; Reset if SIGN flag is set
		    CONDITIONAL-RESET-CARRY  ; Reset if CARRY flag is set
		    ALU-INPUT-A-CLK          ; Writes value on DATABUS to ALU A input register
		    ALU-INPUT-A-CLR          ; Clears ALU A input register
		    ALU-INPUT-B-CLK          ; Writes value on DATABUS to ALU B input register
		    ALU-INPUT-B-CLR          ; Clears ALU B input register
		    OPERAND-SOURCE-SELECT    ; Selects source for register OE/CLK decoders (microcode or operand register)
		    REGISTER-CLK-0           ; Selects one of 16 registers for write
		    REGISTER-CLK-1
		    REGISTER-CLK-2
		    REGISTER-CLK-3
		    REGISTER-OE-0            ; Selects one of 16 registers for output enable
		    REGISTER-OE-1
		    REGISTER-OE-2
		    REGISTER-OE-3
		    RESET-STATE              ; Resets the Instruction Register & Mircocode State register
		    INSTRUCTION-REGISTER-CLK ; Writes value on databus to Instruction Register
		    INTERUPTS-OFF            ; Turns interrupts off
		    INTERRUPTS-CHECK         ; Checks if interrupt is requested (will then handle interrupt if present)
		    INTERRUPTS-CLR/ON        ; Clears interrupt request and turns interrupts back on
		    OE-REGISTER              ; Enables output of selected register to DATABUS
		    CLK-REGISTER)            ; Writes value of DATABUS to selected register
                    SWAP-REGISTER-OE-CLK))

;;; fetches an instruction from memory
(define instruction-fetch '(((REGISTER-OE-0 HIGH) (REGISTER-OE-1 HIGH) (REGISTER-OE-2 HIGH) (REGISTER-OE-3 HIGH) (OPERAND-SOURCE-SELECT HIGH) (OE-REGISTER HIGH))
			    ((ALU-INPUT-A-CLK HIGH) (ALU-FUNCTION-SELECT-3 HIGH))
			    ((ALU-INPUT-A-CLK LOW) (OE-REGISTER LOW) (OPERAND-SOURCE-SELECT LOW) (ALU-OUTPUT HIGH) (REGISTER-CLK-0 HIGH) (REGISTER-CLK-1 HIGH) (REGISTER-CLK-2 HIGH) (REGISTER-CLK-3 HIGH))
			    ((CLK-REGISTER HIGH) (CLK-MEM-ADDR))
			    ((CLK-REGISTER LOW) (ALU-OUTPUT LOW))
			    ((MEMORY-OUTPUT-ENABLE HIGH))
			    ((INSTRUCTION-REGISTER-CLK HIGH))
			    ((INSTRUCTION-REGISTER-CLK LOW) (MEMORY-OUTPUT-ENABLE LOW))))

(define interrupt-check '(((INTERRUPT-CHECK HIGH))
			  ((MEMORY-OUTPUT-ENABLE HIGH) (MEMORY-BUS-ENABLE HIGH) (INTERRUPT-CHECK OFF))
			  ((INSTRUCTION-REGISTER-CLK HIGH))))

;;; increments program counter and resets state
(define nop-instruction '(((RESET-STATE))))

;;; two register arithmetic functions
(define add-instruction '(((OE-REGISTER HIGH))
			  ((ALU-INPUT-A-CLK HIGH))
			  ((SWAP-REGISTER-OE-CLK HIGH))
			  ((ALU-INPUT-B-CLK HIGH))
			  ((OE-REGISTER LOW) (SWAP-REGISTER-OE-CLK LOW)) ;;; alu function select in here
			  ((ALU-OUTPUT HIGH))
			  ((CLK-REGISTER))
			  ((ALU-OUTPUT LOW))
			  ((RESET-STATE HIGH))))


			  
;;; instruction-fetch clock diagram looks like:
;;;    http://i.imgur.com/Cd4VNbS.jpeg
